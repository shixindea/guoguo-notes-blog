{"content":"<h2 id=\"_1-setstate\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-setstate\"><span>1. setState</span></a></h2>\n<h3 id=\"setstate更新状态的2种写法\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#setstate更新状态的2种写法\"><span>setState更新状态的2种写法</span></a></h3>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>\t(1). setState(stateChange, [callback])------对象式的setState</span></span>\n<span class=\"line\"><span>            1.stateChange为状态改变对象(该对象可以体现出状态的更改)</span></span>\n<span class=\"line\"><span>            2.callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用</span></span>\n<span class=\"line\"><span>\t\t\t\t\t</span></span>\n<span class=\"line\"><span>\t(2). setState(updater, [callback])------函数式的setState</span></span>\n<span class=\"line\"><span>            1.updater为返回stateChange对象的函数。</span></span>\n<span class=\"line\"><span>            2.updater可以接收到state和props。</span></span>\n<span class=\"line\"><span>            4.callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。</span></span>\n<span class=\"line\"><span>总结:</span></span>\n<span class=\"line\"><span>\t\t1.对象式的setState是函数式的setState的简写方式(语法糖)</span></span>\n<span class=\"line\"><span>\t\t2.使用原则：</span></span>\n<span class=\"line\"><span>\t\t\t\t(1).如果新状态不依赖于原状态 ===> 使用对象方式</span></span>\n<span class=\"line\"><span>\t\t\t\t(2).如果新状态依赖于原状态 ===> 使用函数方式</span></span>\n<span class=\"line\"><span>\t\t\t\t(3).如果需要在setState()执行后获取最新的状态数据, </span></span>\n<span class=\"line\"><span>\t\t\t\t\t要在第二个callback函数中读取</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><hr>\n<h2 id=\"_2-lazyload\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-lazyload\"><span>2. lazyLoad</span></a></h2>\n<h3 id=\"路由组件的lazyload\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#路由组件的lazyload\"><span>路由组件的lazyLoad</span></a></h3>\n<div class=\"language-js line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"js\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-js\"><span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">\t//1.通过React的lazy函数配合import()函数动态加载路由组件 ===> 路由组件代码会被分开打包</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">\tconst</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> Login</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> lazy</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(()=></span><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">import</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">@/pages/Login</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">))</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">\t</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">\t//2.通过&#x3C;Suspense>指定在加载得到路由打包文件前显示一个自定义loading界面</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">\t&#x3C;</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">Suspense</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> fallback</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">={&#x3C;</span><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\">h1</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">></span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">loading.....</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">&#x3C;/</span><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\">h1</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">>}></span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">        &#x3C;</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">Switch</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">></span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">            &#x3C;</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">Route</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> path</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">=</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">\"</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">/xxx</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">\"</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> component</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">={</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">Xxxx</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}/></span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">            &#x3C;</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">Redirect</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> to</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">=</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">\"</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">/login</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">\"</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">/></span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">        &#x3C;/</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">Switch</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">></span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">    &#x3C;/</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">Suspense</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">></span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><hr>\n<h2 id=\"_3-hooks\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-hooks\"><span>3. Hooks</span></a></h2>\n<h4 id=\"_1-react-hook-hooks是什么\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-react-hook-hooks是什么\"><span>1. React Hook/Hooks是什么?</span></a></h4>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>(1). Hook是React 16.8.0版本增加的新特性/新语法</span></span>\n<span class=\"line\"><span>(2). 可以让你在函数组件中使用 state 以及其他的 React 特性</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4 id=\"_2-三个常用的hook\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-三个常用的hook\"><span>2. 三个常用的Hook</span></a></h4>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>(1). State Hook: React.useState()</span></span>\n<span class=\"line\"><span>(2). Effect Hook: React.useEffect()</span></span>\n<span class=\"line\"><span>(3). Ref Hook: React.useRef()</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4 id=\"_3-state-hook\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-state-hook\"><span>3. State Hook</span></a></h4>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>(1). State Hook让函数组件也可以有state状态, 并进行状态数据的读写操作</span></span>\n<span class=\"line\"><span>(2). 语法: const [xxx, setXxx] = React.useState(initValue)  </span></span>\n<span class=\"line\"><span>(3). useState()说明:</span></span>\n<span class=\"line\"><span>        参数: 第一次初始化指定的值在内部作缓存</span></span>\n<span class=\"line\"><span>        返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数</span></span>\n<span class=\"line\"><span>(4). setXxx()2种写法:</span></span>\n<span class=\"line\"><span>        setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值</span></span>\n<span class=\"line\"><span>        setXxx(value => newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4 id=\"_4-effect-hook\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-effect-hook\"><span>4. Effect Hook</span></a></h4>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>(1). Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)</span></span>\n<span class=\"line\"><span>(2). React中的副作用操作:</span></span>\n<span class=\"line\"><span>        发ajax请求数据获取</span></span>\n<span class=\"line\"><span>        设置订阅 / 启动定时器</span></span>\n<span class=\"line\"><span>        手动更改真实DOM</span></span>\n<span class=\"line\"><span>(3). 语法和说明: </span></span>\n<span class=\"line\"><span>        useEffect(() => { </span></span>\n<span class=\"line\"><span>          // 在此可以执行任何带副作用操作</span></span>\n<span class=\"line\"><span>          return () => { // 在组件卸载前执行</span></span>\n<span class=\"line\"><span>            // 在此做一些收尾工作, 比如清除定时器/取消订阅等</span></span>\n<span class=\"line\"><span>          }</span></span>\n<span class=\"line\"><span>        }, [stateValue]) // 如果指定的是[], 回调函数只会在第一次render()后执行</span></span>\n<span class=\"line\"><span>    </span></span>\n<span class=\"line\"><span>(4). 可以把 useEffect Hook 看做如下三个函数的组合</span></span>\n<span class=\"line\"><span>        componentDidMount()</span></span>\n<span class=\"line\"><span>        componentDidUpdate()</span></span>\n<span class=\"line\"><span>    \tcomponentWillUnmount()</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4 id=\"_5-ref-hook\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_5-ref-hook\"><span>5. Ref Hook</span></a></h4>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>(1). Ref Hook可以在函数组件中存储/查找组件内的标签或任意其它数据</span></span>\n<span class=\"line\"><span>(2). 语法: const refContainer = useRef()</span></span>\n<span class=\"line\"><span>(3). 作用:保存标签对象,功能与React.createRef()一样</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><hr>\n<h2 id=\"_4-fragment\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-fragment\"><span>4. Fragment</span></a></h2>\n<h3 id=\"使用\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#使用\"><span>使用</span></a></h3>\n<pre><code>&lt;Fragment&gt;&lt;Fragment&gt;\n&lt;&gt;&lt;/&gt;\n</code></pre>\n<h3 id=\"作用\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#作用\"><span>作用</span></a></h3>\n<blockquote>\n<p>可以不用必须有一个真实的DOM根标签了</p>\n</blockquote>\n<hr/>\n## 5. Context\n<h3 id=\"理解\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#理解\"><span>理解</span></a></h3>\n<blockquote>\n<p>一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信</p>\n</blockquote>\n<h3 id=\"使用-1\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#使用-1\"><span>使用</span></a></h3>\n<div class=\"language-js line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"js\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-js\"><span class=\"line\"><span style=\"--shiki-light:#2F798A;--shiki-dark:#4C9A91\">1</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">) </span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">创建Context容器对象</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">：</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">\tconst</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> XxxContext</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> React</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">createContext</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">()</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">  </span></span>\n<span class=\"line\"><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">\t</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#2F798A;--shiki-dark:#4C9A91\">2</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">) </span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">渲染子组时</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">，</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">外面包裹xxxContext</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">Provider</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">,</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> 通过value属性给后代组件传递数据</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">：</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">\t&#x3C;</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">xxxContext.Provider</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> value</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">={</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">数据</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}></span></span>\n<span class=\"line\"><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">\t\t子组件</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">    &#x3C;/</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">xxxContext.Provider</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">></span></span>\n<span class=\"line\"><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">    </span></span>\n<span class=\"line\"><span style=\"--shiki-light:#2F798A;--shiki-dark:#4C9A91\">3</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">) </span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">后代组件读取数据</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">：</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">\t//第一种方式:仅适用于类组件 </span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">\t  static</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> contextType</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> xxxContext</span><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">  // 声明接收context</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#A65E2B;--shiki-dark:#C99076\">\t  this</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">context</span><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\"> // 读取context中的value数据</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">\t  </span></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">\t//第二种方式: 函数组件与类组件都可以</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">\t  &#x3C;</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">xxxContext.Consumer</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">></span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">\t    {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">\t      value</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =></span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> (</span><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\"> // value就是context中的value数据</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">\t        要显示的内容</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">\t      )</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">\t    }</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">\t  &#x3C;/</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">xxxContext.Consumer</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">></span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3 id=\"注意\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#注意\"><span>注意</span></a></h3>\n<pre><code>在应用开发中一般不用context, 一般都它的封装react插件\n</code></pre>\n<hr/>\n## 6. 组件优化\n<h3 id=\"component的2个问题\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#component的2个问题\"><span>Component的2个问题</span></a></h3>\n<blockquote>\n<ol>\n<li>\n<p>只要执行setState(),即使不改变状态数据, 组件也会重新render()</p>\n</li>\n<li>\n<p>只当前组件重新render(), 就会自动重新render子组件 ==&gt; 效率低</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"效率高的做法\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#效率高的做法\"><span>效率高的做法</span></a></h3>\n<blockquote>\n<p>只有当组件的state或props数据发生改变时才重新render()</p>\n</blockquote>\n<h3 id=\"原因\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#原因\"><span>原因</span></a></h3>\n<blockquote>\n<p>Component中的shouldComponentUpdate()总是返回true</p>\n</blockquote>\n<h3 id=\"解决\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#解决\"><span>解决</span></a></h3>\n<pre><code>办法1: \n\t重写shouldComponentUpdate()方法\n\t比较新旧state或props数据, 如果有变化才返回true, 如果没有返回false\n办法2:  \n\t使用PureComponent\n\tPureComponent重写了shouldComponentUpdate(), 只有state或props数据有变化才返回true\n\t注意: \n\t\t只是进行state和props数据的浅比较, 如果只是数据对象内部数据变了, 返回false  \n\t\t不要直接修改state数据, 而是要产生新数据\n项目中一般使用PureComponent来优化\n</code></pre>\n<hr/>\n## 7. render props\n<h3 id=\"如何向组件内部动态传入带内容的结构-标签\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#如何向组件内部动态传入带内容的结构-标签\"><span>如何向组件内部动态传入带内容的结构(标签)?</span></a></h3>\n<pre><code>Vue中: \n\t使用slot技术, 也就是通过组件标签体传入结构  &lt;AA&gt;&lt;BB/&gt;&lt;/AA&gt;\nReact中:\n\t使用children props: 通过组件标签体传入结构\n\t使用render props: 通过组件标签属性传入结构, 一般用render函数属性\n</code></pre>\n<h3 id=\"children-props\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#children-props\"><span>children props</span></a></h3>\n<pre><code>&lt;A&gt;\n  &lt;B&gt;xxxx&lt;/B&gt;\n&lt;/A&gt;\n{this.props.children}\n问题: 如果B组件需要A组件内的数据, ==&gt; 做不到 \n</code></pre>\n<h3 id=\"render-props\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#render-props\"><span>render props</span></a></h3>\n<pre><code>&lt;A render={(data) =&gt; &lt;C data={data}&gt;&lt;/C&gt;}&gt;&lt;/A&gt;\nA组件: {this.props.render(内部state数据)}\nC组件: 读取A组件传入的数据显示 {this.props.data} \n</code></pre>\n<hr/>\n## 8. 错误边界\n<h4 id=\"理解-1\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#理解-1\"><span>理解：</span></a></h4>\n<p>错误边界：用来捕获后代组件错误，渲染出备用页面</p>\n<h4 id=\"特点\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#特点\"><span>特点：</span></a></h4>\n<p>只能捕获后代组件生命周期产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误</p>\n<h5 id=\"使用方式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#使用方式\"><span>使用方式：</span></a></h5>\n<p>getDerivedStateFromError配合componentDidCatch</p>\n<div class=\"language-js line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"js\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-js\"><span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">// 生命周期函数，一旦后台组件报错，就会触发</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">static</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> getDerivedStateFromError</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">error</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">)</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">    console</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">log</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">error</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">);</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">    // 在render之前触发</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">    // 返回新的state</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\">    return</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">        hasError</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">:</span><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\"> true</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">,</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">    };</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">componentDidCatch</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">error</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">,</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> info</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">)</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">    // 统计页面的错误。发送请求发送到后台去</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">    console</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">log</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">error</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">,</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> info</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">);</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2 id=\"_9-组件通信方式总结\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_9-组件通信方式总结\"><span>9. 组件通信方式总结</span></a></h2>\n<h4 id=\"方式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#方式\"><span>方式：</span></a></h4>\n<pre><code>\tprops：\n\t\t(1).children props\n\t\t(2).render props\n\t消息订阅-发布：\n\t\tpubs-sub、event等等\n\t集中式管理：\n\t\tredux、dva等等\n\tconText:\n\t\t生产者-消费者模式\n</code></pre>\n<h4 id=\"组件间的关系\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#组件间的关系\"><span>组件间的关系</span></a></h4>\n<pre><code>\t父子组件：props\n\t兄弟组件(非嵌套组件)：消息订阅-发布、集中式管理\n\t祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(用的少)\n</code></pre>\n","env":{"base":"/","filePath":"/Users/guoguo/code/my-project/guoguo-notes-v2/docs/React笔记/尚硅谷React扩展笔记.md","filePathRelative":"React笔记/尚硅谷React扩展笔记.md","frontmatter":{"title":"React扩展","date":"2022-08-04T00:00:00.000Z","tags":["React"],"categories":["自学篇"],"createTime":"2025/08/24 00:25:17","permalink":"/article/pd67uli2/"},"sfcBlocks":{"template":{"type":"template","content":"<template><h2 id=\"_1-setstate\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-setstate\"><span>1. setState</span></a></h2>\n<h3 id=\"setstate更新状态的2种写法\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#setstate更新状态的2种写法\"><span>setState更新状态的2种写法</span></a></h3>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>\t(1). setState(stateChange, [callback])------对象式的setState</span></span>\n<span class=\"line\"><span>            1.stateChange为状态改变对象(该对象可以体现出状态的更改)</span></span>\n<span class=\"line\"><span>            2.callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用</span></span>\n<span class=\"line\"><span>\t\t\t\t\t</span></span>\n<span class=\"line\"><span>\t(2). setState(updater, [callback])------函数式的setState</span></span>\n<span class=\"line\"><span>            1.updater为返回stateChange对象的函数。</span></span>\n<span class=\"line\"><span>            2.updater可以接收到state和props。</span></span>\n<span class=\"line\"><span>            4.callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。</span></span>\n<span class=\"line\"><span>总结:</span></span>\n<span class=\"line\"><span>\t\t1.对象式的setState是函数式的setState的简写方式(语法糖)</span></span>\n<span class=\"line\"><span>\t\t2.使用原则：</span></span>\n<span class=\"line\"><span>\t\t\t\t(1).如果新状态不依赖于原状态 ===> 使用对象方式</span></span>\n<span class=\"line\"><span>\t\t\t\t(2).如果新状态依赖于原状态 ===> 使用函数方式</span></span>\n<span class=\"line\"><span>\t\t\t\t(3).如果需要在setState()执行后获取最新的状态数据, </span></span>\n<span class=\"line\"><span>\t\t\t\t\t要在第二个callback函数中读取</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><hr>\n<h2 id=\"_2-lazyload\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-lazyload\"><span>2. lazyLoad</span></a></h2>\n<h3 id=\"路由组件的lazyload\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#路由组件的lazyload\"><span>路由组件的lazyLoad</span></a></h3>\n<div class=\"language-js line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"js\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-js\"><span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">\t//1.通过React的lazy函数配合import()函数动态加载路由组件 ===> 路由组件代码会被分开打包</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">\tconst</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> Login</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> lazy</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(()=></span><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">import</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">@/pages/Login</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">))</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">\t</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">\t//2.通过&#x3C;Suspense>指定在加载得到路由打包文件前显示一个自定义loading界面</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">\t&#x3C;</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">Suspense</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> fallback</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">={&#x3C;</span><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\">h1</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">></span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">loading.....</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">&#x3C;/</span><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\">h1</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">>}></span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">        &#x3C;</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">Switch</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">></span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">            &#x3C;</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">Route</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> path</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">=</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">\"</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">/xxx</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">\"</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> component</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">={</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">Xxxx</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}/></span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">            &#x3C;</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">Redirect</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> to</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">=</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">\"</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">/login</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">\"</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">/></span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">        &#x3C;/</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">Switch</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">></span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">    &#x3C;/</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">Suspense</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">></span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><hr>\n<h2 id=\"_3-hooks\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-hooks\"><span>3. Hooks</span></a></h2>\n<h4 id=\"_1-react-hook-hooks是什么\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-react-hook-hooks是什么\"><span>1. React Hook/Hooks是什么?</span></a></h4>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>(1). Hook是React 16.8.0版本增加的新特性/新语法</span></span>\n<span class=\"line\"><span>(2). 可以让你在函数组件中使用 state 以及其他的 React 特性</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4 id=\"_2-三个常用的hook\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-三个常用的hook\"><span>2. 三个常用的Hook</span></a></h4>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>(1). State Hook: React.useState()</span></span>\n<span class=\"line\"><span>(2). Effect Hook: React.useEffect()</span></span>\n<span class=\"line\"><span>(3). Ref Hook: React.useRef()</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4 id=\"_3-state-hook\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-state-hook\"><span>3. State Hook</span></a></h4>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>(1). State Hook让函数组件也可以有state状态, 并进行状态数据的读写操作</span></span>\n<span class=\"line\"><span>(2). 语法: const [xxx, setXxx] = React.useState(initValue)  </span></span>\n<span class=\"line\"><span>(3). useState()说明:</span></span>\n<span class=\"line\"><span>        参数: 第一次初始化指定的值在内部作缓存</span></span>\n<span class=\"line\"><span>        返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数</span></span>\n<span class=\"line\"><span>(4). setXxx()2种写法:</span></span>\n<span class=\"line\"><span>        setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值</span></span>\n<span class=\"line\"><span>        setXxx(value => newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4 id=\"_4-effect-hook\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-effect-hook\"><span>4. Effect Hook</span></a></h4>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>(1). Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)</span></span>\n<span class=\"line\"><span>(2). React中的副作用操作:</span></span>\n<span class=\"line\"><span>        发ajax请求数据获取</span></span>\n<span class=\"line\"><span>        设置订阅 / 启动定时器</span></span>\n<span class=\"line\"><span>        手动更改真实DOM</span></span>\n<span class=\"line\"><span>(3). 语法和说明: </span></span>\n<span class=\"line\"><span>        useEffect(() => { </span></span>\n<span class=\"line\"><span>          // 在此可以执行任何带副作用操作</span></span>\n<span class=\"line\"><span>          return () => { // 在组件卸载前执行</span></span>\n<span class=\"line\"><span>            // 在此做一些收尾工作, 比如清除定时器/取消订阅等</span></span>\n<span class=\"line\"><span>          }</span></span>\n<span class=\"line\"><span>        }, [stateValue]) // 如果指定的是[], 回调函数只会在第一次render()后执行</span></span>\n<span class=\"line\"><span>    </span></span>\n<span class=\"line\"><span>(4). 可以把 useEffect Hook 看做如下三个函数的组合</span></span>\n<span class=\"line\"><span>        componentDidMount()</span></span>\n<span class=\"line\"><span>        componentDidUpdate()</span></span>\n<span class=\"line\"><span>    \tcomponentWillUnmount()</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4 id=\"_5-ref-hook\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_5-ref-hook\"><span>5. Ref Hook</span></a></h4>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>(1). Ref Hook可以在函数组件中存储/查找组件内的标签或任意其它数据</span></span>\n<span class=\"line\"><span>(2). 语法: const refContainer = useRef()</span></span>\n<span class=\"line\"><span>(3). 作用:保存标签对象,功能与React.createRef()一样</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><hr>\n<h2 id=\"_4-fragment\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-fragment\"><span>4. Fragment</span></a></h2>\n<h3 id=\"使用\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#使用\"><span>使用</span></a></h3>\n<pre><code>&lt;Fragment&gt;&lt;Fragment&gt;\n&lt;&gt;&lt;/&gt;\n</code></pre>\n<h3 id=\"作用\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#作用\"><span>作用</span></a></h3>\n<blockquote>\n<p>可以不用必须有一个真实的DOM根标签了</p>\n</blockquote>\n<hr/>\n## 5. Context\n<h3 id=\"理解\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#理解\"><span>理解</span></a></h3>\n<blockquote>\n<p>一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信</p>\n</blockquote>\n<h3 id=\"使用-1\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#使用-1\"><span>使用</span></a></h3>\n<div class=\"language-js line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"js\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-js\"><span class=\"line\"><span style=\"--shiki-light:#2F798A;--shiki-dark:#4C9A91\">1</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">) </span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">创建Context容器对象</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">：</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">\tconst</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> XxxContext</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> React</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">createContext</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">()</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">  </span></span>\n<span class=\"line\"><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">\t</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#2F798A;--shiki-dark:#4C9A91\">2</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">) </span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">渲染子组时</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">，</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">外面包裹xxxContext</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">Provider</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">,</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> 通过value属性给后代组件传递数据</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">：</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">\t&#x3C;</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">xxxContext.Provider</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> value</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">={</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">数据</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}></span></span>\n<span class=\"line\"><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">\t\t子组件</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">    &#x3C;/</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">xxxContext.Provider</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">></span></span>\n<span class=\"line\"><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">    </span></span>\n<span class=\"line\"><span style=\"--shiki-light:#2F798A;--shiki-dark:#4C9A91\">3</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">) </span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">后代组件读取数据</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">：</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">\t//第一种方式:仅适用于类组件 </span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">\t  static</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> contextType</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> xxxContext</span><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">  // 声明接收context</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#A65E2B;--shiki-dark:#C99076\">\t  this</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">context</span><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\"> // 读取context中的value数据</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">\t  </span></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">\t//第二种方式: 函数组件与类组件都可以</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">\t  &#x3C;</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">xxxContext.Consumer</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">></span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">\t    {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">\t      value</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =></span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> (</span><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\"> // value就是context中的value数据</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">\t        要显示的内容</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">\t      )</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">\t    }</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">\t  &#x3C;/</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">xxxContext.Consumer</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">></span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3 id=\"注意\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#注意\"><span>注意</span></a></h3>\n<pre><code>在应用开发中一般不用context, 一般都它的封装react插件\n</code></pre>\n<hr/>\n## 6. 组件优化\n<h3 id=\"component的2个问题\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#component的2个问题\"><span>Component的2个问题</span></a></h3>\n<blockquote>\n<ol>\n<li>\n<p>只要执行setState(),即使不改变状态数据, 组件也会重新render()</p>\n</li>\n<li>\n<p>只当前组件重新render(), 就会自动重新render子组件 ==&gt; 效率低</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"效率高的做法\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#效率高的做法\"><span>效率高的做法</span></a></h3>\n<blockquote>\n<p>只有当组件的state或props数据发生改变时才重新render()</p>\n</blockquote>\n<h3 id=\"原因\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#原因\"><span>原因</span></a></h3>\n<blockquote>\n<p>Component中的shouldComponentUpdate()总是返回true</p>\n</blockquote>\n<h3 id=\"解决\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#解决\"><span>解决</span></a></h3>\n<pre><code>办法1: \n\t重写shouldComponentUpdate()方法\n\t比较新旧state或props数据, 如果有变化才返回true, 如果没有返回false\n办法2:  \n\t使用PureComponent\n\tPureComponent重写了shouldComponentUpdate(), 只有state或props数据有变化才返回true\n\t注意: \n\t\t只是进行state和props数据的浅比较, 如果只是数据对象内部数据变了, 返回false  \n\t\t不要直接修改state数据, 而是要产生新数据\n项目中一般使用PureComponent来优化\n</code></pre>\n<hr/>\n## 7. render props\n<h3 id=\"如何向组件内部动态传入带内容的结构-标签\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#如何向组件内部动态传入带内容的结构-标签\"><span>如何向组件内部动态传入带内容的结构(标签)?</span></a></h3>\n<pre><code>Vue中: \n\t使用slot技术, 也就是通过组件标签体传入结构  &lt;AA&gt;&lt;BB/&gt;&lt;/AA&gt;\nReact中:\n\t使用children props: 通过组件标签体传入结构\n\t使用render props: 通过组件标签属性传入结构, 一般用render函数属性\n</code></pre>\n<h3 id=\"children-props\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#children-props\"><span>children props</span></a></h3>\n<pre><code>&lt;A&gt;\n  &lt;B&gt;xxxx&lt;/B&gt;\n&lt;/A&gt;\n{this.props.children}\n问题: 如果B组件需要A组件内的数据, ==&gt; 做不到 \n</code></pre>\n<h3 id=\"render-props\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#render-props\"><span>render props</span></a></h3>\n<pre><code>&lt;A render={(data) =&gt; &lt;C data={data}&gt;&lt;/C&gt;}&gt;&lt;/A&gt;\nA组件: {this.props.render(内部state数据)}\nC组件: 读取A组件传入的数据显示 {this.props.data} \n</code></pre>\n<hr/>\n## 8. 错误边界\n<h4 id=\"理解-1\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#理解-1\"><span>理解：</span></a></h4>\n<p>错误边界：用来捕获后代组件错误，渲染出备用页面</p>\n<h4 id=\"特点\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#特点\"><span>特点：</span></a></h4>\n<p>只能捕获后代组件生命周期产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误</p>\n<h5 id=\"使用方式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#使用方式\"><span>使用方式：</span></a></h5>\n<p>getDerivedStateFromError配合componentDidCatch</p>\n<div class=\"language-js line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"js\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-js\"><span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">// 生命周期函数，一旦后台组件报错，就会触发</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">static</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> getDerivedStateFromError</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">error</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">)</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">    console</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">log</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">error</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">);</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">    // 在render之前触发</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">    // 返回新的state</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\">    return</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">        hasError</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">:</span><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\"> true</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">,</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">    };</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">componentDidCatch</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">error</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">,</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> info</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">)</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">    // 统计页面的错误。发送请求发送到后台去</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">    console</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">log</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">error</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">,</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> info</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">);</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2 id=\"_9-组件通信方式总结\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_9-组件通信方式总结\"><span>9. 组件通信方式总结</span></a></h2>\n<h4 id=\"方式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#方式\"><span>方式：</span></a></h4>\n<pre><code>\tprops：\n\t\t(1).children props\n\t\t(2).render props\n\t消息订阅-发布：\n\t\tpubs-sub、event等等\n\t集中式管理：\n\t\tredux、dva等等\n\tconText:\n\t\t生产者-消费者模式\n</code></pre>\n<h4 id=\"组件间的关系\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#组件间的关系\"><span>组件间的关系</span></a></h4>\n<pre><code>\t父子组件：props\n\t兄弟组件(非嵌套组件)：消息订阅-发布、集中式管理\n\t祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(用的少)\n</code></pre>\n</template>","contentStripped":"<h2 id=\"_1-setstate\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-setstate\"><span>1. setState</span></a></h2>\n<h3 id=\"setstate更新状态的2种写法\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#setstate更新状态的2种写法\"><span>setState更新状态的2种写法</span></a></h3>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>\t(1). setState(stateChange, [callback])------对象式的setState</span></span>\n<span class=\"line\"><span>            1.stateChange为状态改变对象(该对象可以体现出状态的更改)</span></span>\n<span class=\"line\"><span>            2.callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用</span></span>\n<span class=\"line\"><span>\t\t\t\t\t</span></span>\n<span class=\"line\"><span>\t(2). setState(updater, [callback])------函数式的setState</span></span>\n<span class=\"line\"><span>            1.updater为返回stateChange对象的函数。</span></span>\n<span class=\"line\"><span>            2.updater可以接收到state和props。</span></span>\n<span class=\"line\"><span>            4.callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。</span></span>\n<span class=\"line\"><span>总结:</span></span>\n<span class=\"line\"><span>\t\t1.对象式的setState是函数式的setState的简写方式(语法糖)</span></span>\n<span class=\"line\"><span>\t\t2.使用原则：</span></span>\n<span class=\"line\"><span>\t\t\t\t(1).如果新状态不依赖于原状态 ===> 使用对象方式</span></span>\n<span class=\"line\"><span>\t\t\t\t(2).如果新状态依赖于原状态 ===> 使用函数方式</span></span>\n<span class=\"line\"><span>\t\t\t\t(3).如果需要在setState()执行后获取最新的状态数据, </span></span>\n<span class=\"line\"><span>\t\t\t\t\t要在第二个callback函数中读取</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><hr>\n<h2 id=\"_2-lazyload\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-lazyload\"><span>2. lazyLoad</span></a></h2>\n<h3 id=\"路由组件的lazyload\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#路由组件的lazyload\"><span>路由组件的lazyLoad</span></a></h3>\n<div class=\"language-js line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"js\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-js\"><span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">\t//1.通过React的lazy函数配合import()函数动态加载路由组件 ===> 路由组件代码会被分开打包</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">\tconst</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> Login</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> lazy</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(()=></span><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">import</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">@/pages/Login</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">))</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">\t</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">\t//2.通过&#x3C;Suspense>指定在加载得到路由打包文件前显示一个自定义loading界面</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">\t&#x3C;</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">Suspense</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> fallback</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">={&#x3C;</span><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\">h1</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">></span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">loading.....</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">&#x3C;/</span><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\">h1</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">>}></span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">        &#x3C;</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">Switch</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">></span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">            &#x3C;</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">Route</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> path</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">=</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">\"</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">/xxx</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">\"</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> component</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">={</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">Xxxx</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}/></span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">            &#x3C;</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">Redirect</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> to</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">=</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">\"</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">/login</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">\"</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">/></span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">        &#x3C;/</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">Switch</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">></span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">    &#x3C;/</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">Suspense</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">></span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><hr>\n<h2 id=\"_3-hooks\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-hooks\"><span>3. Hooks</span></a></h2>\n<h4 id=\"_1-react-hook-hooks是什么\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-react-hook-hooks是什么\"><span>1. React Hook/Hooks是什么?</span></a></h4>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>(1). Hook是React 16.8.0版本增加的新特性/新语法</span></span>\n<span class=\"line\"><span>(2). 可以让你在函数组件中使用 state 以及其他的 React 特性</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4 id=\"_2-三个常用的hook\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-三个常用的hook\"><span>2. 三个常用的Hook</span></a></h4>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>(1). State Hook: React.useState()</span></span>\n<span class=\"line\"><span>(2). Effect Hook: React.useEffect()</span></span>\n<span class=\"line\"><span>(3). Ref Hook: React.useRef()</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4 id=\"_3-state-hook\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-state-hook\"><span>3. State Hook</span></a></h4>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>(1). State Hook让函数组件也可以有state状态, 并进行状态数据的读写操作</span></span>\n<span class=\"line\"><span>(2). 语法: const [xxx, setXxx] = React.useState(initValue)  </span></span>\n<span class=\"line\"><span>(3). useState()说明:</span></span>\n<span class=\"line\"><span>        参数: 第一次初始化指定的值在内部作缓存</span></span>\n<span class=\"line\"><span>        返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数</span></span>\n<span class=\"line\"><span>(4). setXxx()2种写法:</span></span>\n<span class=\"line\"><span>        setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值</span></span>\n<span class=\"line\"><span>        setXxx(value => newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4 id=\"_4-effect-hook\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-effect-hook\"><span>4. Effect Hook</span></a></h4>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>(1). Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)</span></span>\n<span class=\"line\"><span>(2). React中的副作用操作:</span></span>\n<span class=\"line\"><span>        发ajax请求数据获取</span></span>\n<span class=\"line\"><span>        设置订阅 / 启动定时器</span></span>\n<span class=\"line\"><span>        手动更改真实DOM</span></span>\n<span class=\"line\"><span>(3). 语法和说明: </span></span>\n<span class=\"line\"><span>        useEffect(() => { </span></span>\n<span class=\"line\"><span>          // 在此可以执行任何带副作用操作</span></span>\n<span class=\"line\"><span>          return () => { // 在组件卸载前执行</span></span>\n<span class=\"line\"><span>            // 在此做一些收尾工作, 比如清除定时器/取消订阅等</span></span>\n<span class=\"line\"><span>          }</span></span>\n<span class=\"line\"><span>        }, [stateValue]) // 如果指定的是[], 回调函数只会在第一次render()后执行</span></span>\n<span class=\"line\"><span>    </span></span>\n<span class=\"line\"><span>(4). 可以把 useEffect Hook 看做如下三个函数的组合</span></span>\n<span class=\"line\"><span>        componentDidMount()</span></span>\n<span class=\"line\"><span>        componentDidUpdate()</span></span>\n<span class=\"line\"><span>    \tcomponentWillUnmount()</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4 id=\"_5-ref-hook\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_5-ref-hook\"><span>5. Ref Hook</span></a></h4>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>(1). Ref Hook可以在函数组件中存储/查找组件内的标签或任意其它数据</span></span>\n<span class=\"line\"><span>(2). 语法: const refContainer = useRef()</span></span>\n<span class=\"line\"><span>(3). 作用:保存标签对象,功能与React.createRef()一样</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><hr>\n<h2 id=\"_4-fragment\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-fragment\"><span>4. Fragment</span></a></h2>\n<h3 id=\"使用\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#使用\"><span>使用</span></a></h3>\n<pre><code>&lt;Fragment&gt;&lt;Fragment&gt;\n&lt;&gt;&lt;/&gt;\n</code></pre>\n<h3 id=\"作用\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#作用\"><span>作用</span></a></h3>\n<blockquote>\n<p>可以不用必须有一个真实的DOM根标签了</p>\n</blockquote>\n<hr/>\n## 5. Context\n<h3 id=\"理解\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#理解\"><span>理解</span></a></h3>\n<blockquote>\n<p>一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信</p>\n</blockquote>\n<h3 id=\"使用-1\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#使用-1\"><span>使用</span></a></h3>\n<div class=\"language-js line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"js\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-js\"><span class=\"line\"><span style=\"--shiki-light:#2F798A;--shiki-dark:#4C9A91\">1</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">) </span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">创建Context容器对象</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">：</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">\tconst</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> XxxContext</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> React</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">createContext</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">()</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">  </span></span>\n<span class=\"line\"><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">\t</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#2F798A;--shiki-dark:#4C9A91\">2</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">) </span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">渲染子组时</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">，</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">外面包裹xxxContext</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">Provider</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">,</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> 通过value属性给后代组件传递数据</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">：</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">\t&#x3C;</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">xxxContext.Provider</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> value</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">={</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">数据</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}></span></span>\n<span class=\"line\"><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">\t\t子组件</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">    &#x3C;/</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">xxxContext.Provider</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">></span></span>\n<span class=\"line\"><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">    </span></span>\n<span class=\"line\"><span style=\"--shiki-light:#2F798A;--shiki-dark:#4C9A91\">3</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">) </span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">后代组件读取数据</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">：</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">\t//第一种方式:仅适用于类组件 </span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">\t  static</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> contextType</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> xxxContext</span><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">  // 声明接收context</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#A65E2B;--shiki-dark:#C99076\">\t  this</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">context</span><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\"> // 读取context中的value数据</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">\t  </span></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">\t//第二种方式: 函数组件与类组件都可以</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">\t  &#x3C;</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">xxxContext.Consumer</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">></span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">\t    {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">\t      value</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =></span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> (</span><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\"> // value就是context中的value数据</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">\t        要显示的内容</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">\t      )</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">\t    }</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">\t  &#x3C;/</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">xxxContext.Consumer</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">></span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3 id=\"注意\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#注意\"><span>注意</span></a></h3>\n<pre><code>在应用开发中一般不用context, 一般都它的封装react插件\n</code></pre>\n<hr/>\n## 6. 组件优化\n<h3 id=\"component的2个问题\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#component的2个问题\"><span>Component的2个问题</span></a></h3>\n<blockquote>\n<ol>\n<li>\n<p>只要执行setState(),即使不改变状态数据, 组件也会重新render()</p>\n</li>\n<li>\n<p>只当前组件重新render(), 就会自动重新render子组件 ==&gt; 效率低</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"效率高的做法\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#效率高的做法\"><span>效率高的做法</span></a></h3>\n<blockquote>\n<p>只有当组件的state或props数据发生改变时才重新render()</p>\n</blockquote>\n<h3 id=\"原因\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#原因\"><span>原因</span></a></h3>\n<blockquote>\n<p>Component中的shouldComponentUpdate()总是返回true</p>\n</blockquote>\n<h3 id=\"解决\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#解决\"><span>解决</span></a></h3>\n<pre><code>办法1: \n\t重写shouldComponentUpdate()方法\n\t比较新旧state或props数据, 如果有变化才返回true, 如果没有返回false\n办法2:  \n\t使用PureComponent\n\tPureComponent重写了shouldComponentUpdate(), 只有state或props数据有变化才返回true\n\t注意: \n\t\t只是进行state和props数据的浅比较, 如果只是数据对象内部数据变了, 返回false  \n\t\t不要直接修改state数据, 而是要产生新数据\n项目中一般使用PureComponent来优化\n</code></pre>\n<hr/>\n## 7. render props\n<h3 id=\"如何向组件内部动态传入带内容的结构-标签\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#如何向组件内部动态传入带内容的结构-标签\"><span>如何向组件内部动态传入带内容的结构(标签)?</span></a></h3>\n<pre><code>Vue中: \n\t使用slot技术, 也就是通过组件标签体传入结构  &lt;AA&gt;&lt;BB/&gt;&lt;/AA&gt;\nReact中:\n\t使用children props: 通过组件标签体传入结构\n\t使用render props: 通过组件标签属性传入结构, 一般用render函数属性\n</code></pre>\n<h3 id=\"children-props\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#children-props\"><span>children props</span></a></h3>\n<pre><code>&lt;A&gt;\n  &lt;B&gt;xxxx&lt;/B&gt;\n&lt;/A&gt;\n{this.props.children}\n问题: 如果B组件需要A组件内的数据, ==&gt; 做不到 \n</code></pre>\n<h3 id=\"render-props\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#render-props\"><span>render props</span></a></h3>\n<pre><code>&lt;A render={(data) =&gt; &lt;C data={data}&gt;&lt;/C&gt;}&gt;&lt;/A&gt;\nA组件: {this.props.render(内部state数据)}\nC组件: 读取A组件传入的数据显示 {this.props.data} \n</code></pre>\n<hr/>\n## 8. 错误边界\n<h4 id=\"理解-1\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#理解-1\"><span>理解：</span></a></h4>\n<p>错误边界：用来捕获后代组件错误，渲染出备用页面</p>\n<h4 id=\"特点\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#特点\"><span>特点：</span></a></h4>\n<p>只能捕获后代组件生命周期产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误</p>\n<h5 id=\"使用方式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#使用方式\"><span>使用方式：</span></a></h5>\n<p>getDerivedStateFromError配合componentDidCatch</p>\n<div class=\"language-js line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"js\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-js\"><span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">// 生命周期函数，一旦后台组件报错，就会触发</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">static</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> getDerivedStateFromError</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">error</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">)</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">    console</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">log</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">error</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">);</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">    // 在render之前触发</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">    // 返回新的state</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\">    return</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">        hasError</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">:</span><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\"> true</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">,</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">    };</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">componentDidCatch</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">error</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">,</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> info</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">)</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">    // 统计页面的错误。发送请求发送到后台去</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">    console</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">log</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">error</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">,</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> info</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">);</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2 id=\"_9-组件通信方式总结\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_9-组件通信方式总结\"><span>9. 组件通信方式总结</span></a></h2>\n<h4 id=\"方式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#方式\"><span>方式：</span></a></h4>\n<pre><code>\tprops：\n\t\t(1).children props\n\t\t(2).render props\n\t消息订阅-发布：\n\t\tpubs-sub、event等等\n\t集中式管理：\n\t\tredux、dva等等\n\tconText:\n\t\t生产者-消费者模式\n</code></pre>\n<h4 id=\"组件间的关系\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#组件间的关系\"><span>组件间的关系</span></a></h4>\n<pre><code>\t父子组件：props\n\t兄弟组件(非嵌套组件)：消息订阅-发布、集中式管理\n\t祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(用的少)\n</code></pre>\n","tagOpen":"<template>","tagClose":"</template>"},"script":null,"scriptSetup":null,"scripts":[],"styles":[],"customBlocks":[]},"content":"## 1. setState\n\n### setState更新状态的2种写法\n\n```\n\t(1). setState(stateChange, [callback])------对象式的setState\n            1.stateChange为状态改变对象(该对象可以体现出状态的更改)\n            2.callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用\n\t\t\t\t\t\n\t(2). setState(updater, [callback])------函数式的setState\n            1.updater为返回stateChange对象的函数。\n            2.updater可以接收到state和props。\n            4.callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。\n总结:\n\t\t1.对象式的setState是函数式的setState的简写方式(语法糖)\n\t\t2.使用原则：\n\t\t\t\t(1).如果新状态不依赖于原状态 ===> 使用对象方式\n\t\t\t\t(2).如果新状态依赖于原状态 ===> 使用函数方式\n\t\t\t\t(3).如果需要在setState()执行后获取最新的状态数据, \n\t\t\t\t\t要在第二个callback函数中读取\n```\n\n\n\n------\n\n\n\n## 2. lazyLoad\n\n### 路由组件的lazyLoad\n\n```js\n\t//1.通过React的lazy函数配合import()函数动态加载路由组件 ===> 路由组件代码会被分开打包\n\tconst Login = lazy(()=>import('@/pages/Login'))\n\t\n\t//2.通过<Suspense>指定在加载得到路由打包文件前显示一个自定义loading界面\n\t<Suspense fallback={<h1>loading.....</h1>}>\n        <Switch>\n            <Route path=\"/xxx\" component={Xxxx}/>\n            <Redirect to=\"/login\"/>\n        </Switch>\n    </Suspense>\n```\n\n\n\n------\n\n\n\n## 3. Hooks\n\n#### 1. React Hook/Hooks是什么?\n\n```\n(1). Hook是React 16.8.0版本增加的新特性/新语法\n(2). 可以让你在函数组件中使用 state 以及其他的 React 特性\n```\n\n#### 2. 三个常用的Hook\n\n```\n(1). State Hook: React.useState()\n(2). Effect Hook: React.useEffect()\n(3). Ref Hook: React.useRef()\n```\n\n#### 3. State Hook\n\n```\n(1). State Hook让函数组件也可以有state状态, 并进行状态数据的读写操作\n(2). 语法: const [xxx, setXxx] = React.useState(initValue)  \n(3). useState()说明:\n        参数: 第一次初始化指定的值在内部作缓存\n        返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数\n(4). setXxx()2种写法:\n        setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值\n        setXxx(value => newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值\n```\n\n#### 4. Effect Hook\n\n```\n(1). Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)\n(2). React中的副作用操作:\n        发ajax请求数据获取\n        设置订阅 / 启动定时器\n        手动更改真实DOM\n(3). 语法和说明: \n        useEffect(() => { \n          // 在此可以执行任何带副作用操作\n          return () => { // 在组件卸载前执行\n            // 在此做一些收尾工作, 比如清除定时器/取消订阅等\n          }\n        }, [stateValue]) // 如果指定的是[], 回调函数只会在第一次render()后执行\n    \n(4). 可以把 useEffect Hook 看做如下三个函数的组合\n        componentDidMount()\n        componentDidUpdate()\n    \tcomponentWillUnmount() \n```\n\n#### 5. Ref Hook\n\n```\n(1). Ref Hook可以在函数组件中存储/查找组件内的标签或任意其它数据\n(2). 语法: const refContainer = useRef()\n(3). 作用:保存标签对象,功能与React.createRef()一样\n```\n\n\n\n------\n\n\n\n## 4. Fragment\n\n### 使用\n\n\t<Fragment><Fragment>\n\t<></>\n\n### 作用\n\n> 可以不用必须有一个真实的DOM根标签了\n\n\n\n<hr/>\n## 5. Context\n\n### 理解\n\n> 一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信\n\n### 使用\n\n```js\n1) 创建Context容器对象：\n\tconst XxxContext = React.createContext()  \n\t\n2) 渲染子组时，外面包裹xxxContext.Provider, 通过value属性给后代组件传递数据：\n\t<xxxContext.Provider value={数据}>\n\t\t子组件\n    </xxxContext.Provider>\n    \n3) 后代组件读取数据：\n\n\t//第一种方式:仅适用于类组件 \n\t  static contextType = xxxContext  // 声明接收context\n\t  this.context // 读取context中的value数据\n\t  \n\t//第二种方式: 函数组件与类组件都可以\n\t  <xxxContext.Consumer>\n\t    {\n\t      value => ( // value就是context中的value数据\n\t        要显示的内容\n\t      )\n\t    }\n\t  </xxxContext.Consumer>\n```\n\n### 注意\n\n\t在应用开发中一般不用context, 一般都它的封装react插件\n\n\n\n<hr/>\n## 6. 组件优化\n\n### Component的2个问题 \n\n> 1. 只要执行setState(),即使不改变状态数据, 组件也会重新render()\n>\n> 2. 只当前组件重新render(), 就会自动重新render子组件 ==> 效率低\n\n### 效率高的做法\n\n>  只有当组件的state或props数据发生改变时才重新render()\n\n### 原因\n\n>  Component中的shouldComponentUpdate()总是返回true\n\n### 解决\n\n\t办法1: \n\t\t重写shouldComponentUpdate()方法\n\t\t比较新旧state或props数据, 如果有变化才返回true, 如果没有返回false\n\t办法2:  \n\t\t使用PureComponent\n\t\tPureComponent重写了shouldComponentUpdate(), 只有state或props数据有变化才返回true\n\t\t注意: \n\t\t\t只是进行state和props数据的浅比较, 如果只是数据对象内部数据变了, 返回false  \n\t\t\t不要直接修改state数据, 而是要产生新数据\n\t项目中一般使用PureComponent来优化\n\n\n\n<hr/>\n## 7. render props\n\n### 如何向组件内部动态传入带内容的结构(标签)?\n\n\tVue中: \n\t\t使用slot技术, 也就是通过组件标签体传入结构  <AA><BB/></AA>\n\tReact中:\n\t\t使用children props: 通过组件标签体传入结构\n\t\t使用render props: 通过组件标签属性传入结构, 一般用render函数属性\n\n### children props\n\n\t<A>\n\t  <B>xxxx</B>\n\t</A>\n\t{this.props.children}\n\t问题: 如果B组件需要A组件内的数据, ==> 做不到 \n\n### render props\n\n\t<A render={(data) => <C data={data}></C>}></A>\n\tA组件: {this.props.render(内部state数据)}\n\tC组件: 读取A组件传入的数据显示 {this.props.data} \n\n\n\n<hr/>\n## 8. 错误边界\n\n#### 理解：\n\n错误边界：用来捕获后代组件错误，渲染出备用页面\n\n#### 特点：\n\n只能捕获后代组件生命周期产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误\n\n##### 使用方式：\n\ngetDerivedStateFromError配合componentDidCatch\n\n```js\n// 生命周期函数，一旦后台组件报错，就会触发\nstatic getDerivedStateFromError(error) {\n    console.log(error);\n    // 在render之前触发\n    // 返回新的state\n    return {\n        hasError: true,\n    };\n}\n\ncomponentDidCatch(error, info) {\n    // 统计页面的错误。发送请求发送到后台去\n    console.log(error, info);\n}\n```\n\n## 9. 组件通信方式总结\n\n#### 方式：\n\n\t\tprops：\n\t\t\t(1).children props\n\t\t\t(2).render props\n\t\t消息订阅-发布：\n\t\t\tpubs-sub、event等等\n\t\t集中式管理：\n\t\t\tredux、dva等等\n\t\tconText:\n\t\t\t生产者-消费者模式\n\n#### 组件间的关系\n\n\t\t父子组件：props\n\t\t兄弟组件(非嵌套组件)：消息订阅-发布、集中式管理\n\t\t祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(用的少)","excerpt":"","includedFiles":[],"tasklistId":0,"title":"","headers":[{"level":2,"title":"1. setState","slug":"_1-setstate","link":"#_1-setstate","children":[{"level":3,"title":"setState更新状态的2种写法","slug":"setstate更新状态的2种写法","link":"#setstate更新状态的2种写法","children":[]}]},{"level":2,"title":"2. lazyLoad","slug":"_2-lazyload","link":"#_2-lazyload","children":[{"level":3,"title":"路由组件的lazyLoad","slug":"路由组件的lazyload","link":"#路由组件的lazyload","children":[]}]},{"level":2,"title":"3. Hooks","slug":"_3-hooks","link":"#_3-hooks","children":[]},{"level":2,"title":"4. Fragment","slug":"_4-fragment","link":"#_4-fragment","children":[{"level":3,"title":"使用","slug":"使用","link":"#使用","children":[]},{"level":3,"title":"作用","slug":"作用","link":"#作用","children":[]},{"level":3,"title":"理解","slug":"理解","link":"#理解","children":[]},{"level":3,"title":"使用","slug":"使用-1","link":"#使用-1","children":[]},{"level":3,"title":"注意","slug":"注意","link":"#注意","children":[]},{"level":3,"title":"Component的2个问题","slug":"component的2个问题","link":"#component的2个问题","children":[]},{"level":3,"title":"效率高的做法","slug":"效率高的做法","link":"#效率高的做法","children":[]},{"level":3,"title":"原因","slug":"原因","link":"#原因","children":[]},{"level":3,"title":"解决","slug":"解决","link":"#解决","children":[]},{"level":3,"title":"如何向组件内部动态传入带内容的结构(标签)?","slug":"如何向组件内部动态传入带内容的结构-标签","link":"#如何向组件内部动态传入带内容的结构-标签","children":[]},{"level":3,"title":"children props","slug":"children-props","link":"#children-props","children":[]},{"level":3,"title":"render props","slug":"render-props","link":"#render-props","children":[]}]},{"level":2,"title":"9. 组件通信方式总结","slug":"_9-组件通信方式总结","link":"#_9-组件通信方式总结","children":[]}]}}
