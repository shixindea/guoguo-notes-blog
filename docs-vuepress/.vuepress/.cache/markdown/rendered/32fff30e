{"content":"<h1 id=\"_1-使用react脚手架创建一个react应用\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-使用react脚手架创建一个react应用\"><span>1. 使用React脚手架创建一个React应用</span></a></h1>\n<h2 id=\"_1-react脚手架\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-react脚手架\"><span>1). react脚手架</span></a></h2>\n<pre><code>1. xxx脚手架: 用来帮助程序员快速创建一个基于xxx库的模板项目\n\t* 包含了所有需要的配置\n\t* 指定好了所有的依赖\n\t* 可以直接安装/编译/运行一个简单效果\n2. react提供了一个专门用于创建react项目的脚手架库: create-react-app\n3. 项目的整体技术架构为: react + webpack + es6  + babel + eslint\n</code></pre>\n<h2 id=\"_2-创建项目并启动\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-创建项目并启动\"><span>2). 创建项目并启动</span></a></h2>\n<pre><code>npm install -g create-react-app\ncreate-react-app react-app\ncd react-app\nnpm start\n</code></pre>\n<h2 id=\"_3-使用脚手架开发的项目的特点\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-使用脚手架开发的项目的特点\"><span>3). 使用脚手架开发的项目的特点</span></a></h2>\n<pre><code>模块化: js是一个一个模块编写的\n组件化: 界面是由多个组件组合编写实现的\n工程化: 实现了自动构建/运行/打包的项目\n</code></pre>\n<h2 id=\"_4-组件化编写项目的流程\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-组件化编写项目的流程\"><span>4). 组件化编写项目的流程</span></a></h2>\n<pre><code>拆分组件\n实现静态组件---&gt;静态页面\n实现动态组件\n\t动态显示初始化数据\n\t交互\n</code></pre>\n<h1 id=\"_2-app1-实现一个评论管理功能\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-app1-实现一个评论管理功能\"><span>2. app1: 实现一个评论管理功能</span></a></h1>\n<h2 id=\"_1-拆分组件\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-拆分组件\"><span>1). 拆分组件:</span></a></h2>\n<pre><code>应用组件: App\n添加评论组件: CommentAdd\n评论项组件: CommentItem\n评论列表组件: CommentList\n</code></pre>\n<h2 id=\"_2-确定组件的state和props\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-确定组件的state和props\"><span>2). 确定组件的state和props:</span></a></h2>\n<pre><code>App: \n\t* state: comments/array\nCommentAdd\n\t* state: username/string, content/string\n\t* props: add/func\ncommentList\n  \t* props: comments/array, delete/func\nCommentItem\n\t* props: comment/object, delete/func, index/number\n</code></pre>\n<h2 id=\"_3-编写静态组件\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-编写静态组件\"><span>3). 编写静态组件</span></a></h2>\n<pre><code>拆分页面\n拆分css\n</code></pre>\n<h2 id=\"_4-实现动态组件\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-实现动态组件\"><span>4). 实现动态组件</span></a></h2>\n<pre><code>1. 动态展示初始化数据\n  * 初始化状态数据\n  * 传递属性数据\n2. 响应用户操作, 更新组件界面\n  * 绑定事件监听, 并处理\n  * 更新state\n</code></pre>\n<h1 id=\"_3-app2-实现github用户搜索功能\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-app2-实现github用户搜索功能\"><span>3. app2: 实现github用户搜索功能</span></a></h1>\n<h2 id=\"_1-react应用中的ajax请求\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-react应用中的ajax请求\"><span>1). react应用中的ajax请求</span></a></h2>\n<pre><code>axios: 包装XMLHttpRequest对象, promise风格, 支持浏览端/node服务器端\nfetch: 浏览器内置语法, promise风格, 老浏览器不支持, 可以引入fetch.js兼容包\n</code></pre>\n<h2 id=\"_2-拆分组件\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-拆分组件\"><span>2). 拆分组件</span></a></h2>\n<pre><code>App\n\t* state: searchName/string\nSearch\n  \t* props: setSearchName/func\nList\n  \t* props: searchName/string\n  \t* state: firstView/bool, loading/bool, users/array, errMsg/string\n</code></pre>\n<h2 id=\"_3-编写组件\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-编写组件\"><span>3). 编写组件</span></a></h2>\n<pre><code>编写静态组件\n编写动态组件\n\tcomponentWillReceiveProps(nextProps): 监视接收到新的props, 发送ajax\n\t使用axios库发送ajax请求\n</code></pre>\n<h1 id=\"_4-组件间通信总结\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-组件间通信总结\"><span>4. 组件间通信总结</span></a></h1>\n<h2 id=\"_1-方式一-通过props传递\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-方式一-通过props传递\"><span>1). 方式一: 通过props传递</span></a></h2>\n<pre><code>共同的数据放在父组件上, 特有的数据放在自己组件内部(state)\n一般数据--&gt;父组件传递数据给子组件--&gt;子组件读取数据\n函数数据--&gt;子组件传递数据给父组件--&gt;子组件调用函数\n问题: 多层传递属性麻烦, 兄弟组件通信不方便\n</code></pre>\n<h2 id=\"_2-方式二-使用消息订阅-subscribe-发布-publish-机制-自定义事件机制\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-方式二-使用消息订阅-subscribe-发布-publish-机制-自定义事件机制\"><span>2). 方式二: 使用消息订阅(subscribe)-发布(publish)机制: 自定义事件机制</span></a></h2>\n<pre><code>工具库: PubSubJS\n下载: npm install pubsub-js --save\n使用: \n  import PubSub from 'pubsub-js' //引入\n  PubSub.subscribe('delete', function(msg, data){ }); //订阅\n  PubSub.publish('delete', data) //发布消息\n优点: 可以支持任意关系组件之间的通信\n</code></pre>\n<h2 id=\"_3-事件监听理解\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-事件监听理解\"><span>3). 事件监听理解</span></a></h2>\n<pre><code>1. DOM事件\n\t* 绑定事件监听\n\t\t* 事件名(类型): 只有有限的几个, 不能随便写\n\t\t* 回调函数\n\t* 用户操作触发事件(event)\n\t\t* 事件名(类型)\n\t\t* 数据\n2. 自定义事件\n\t* 绑定事件监听\n\t\t* 事件名(类型): 任意\n\t\t* 回调函数: 通过形参接收数据, 在函数体处理事件\n\t* 触发事件(编码)\n\t\t* 事件名(类型): 与绑定的事件监听的事件名一致\n\t\t* 数据: 会自动传递给回调函数\n</code></pre>\n<h1 id=\"_5-es6新语法总结\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_5-es6新语法总结\"><span>5. ES6新语法总结</span></a></h1>\n<pre><code>定义变量/常量: const/let\n解构赋值: let {a, b} = this.props   import {aa} from 'xxx'\n对象的简洁表达: {a, b}\n箭头函数: \n\t组件的自定义方法: xxx = () =&gt; {}\n\tmap/filter的回调方法: (item, index) =&gt; {}\n\t优点:\n\t\t* 简洁\n\t\t* 没有自己的this,使用引用this查找的是外部this\n扩展运算符: ...\n\t拆解对象:  const MyProps = {}, &lt;Xxx {...MyProps}&gt;\n类: class/extends/constructor/super\nES6模块化: export default | import\n</code></pre>\n<h1 id=\"_6-项目打包运行\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_6-项目打包运行\"><span>6. 项目打包运行</span></a></h1>\n<pre><code>npm run build  //生成打包文件\nnpm install -g serve  //全局下载服务器包\nserve build  //通过服务器命令运行打包项目\n访问: http://localhost:5000  //浏览器访问\n</code></pre>\n","env":{"base":"/","filePath":"/Users/guoguo/code/my-project/guoguo-notes-v2/docs/React笔记/02_react案例_笔记.md","filePathRelative":"React笔记/02_react案例_笔记.md","frontmatter":{"title":"React案例","date":"2022-08-04T00:00:00.000Z","tags":["React","案例"],"categories":["自学篇"],"createTime":"2025/08/24 00:25:17","permalink":"/article/v3e00uw9/"},"sfcBlocks":{"template":{"type":"template","content":"<template><h1 id=\"_1-使用react脚手架创建一个react应用\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-使用react脚手架创建一个react应用\"><span>1. 使用React脚手架创建一个React应用</span></a></h1>\n<h2 id=\"_1-react脚手架\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-react脚手架\"><span>1). react脚手架</span></a></h2>\n<pre><code>1. xxx脚手架: 用来帮助程序员快速创建一个基于xxx库的模板项目\n\t* 包含了所有需要的配置\n\t* 指定好了所有的依赖\n\t* 可以直接安装/编译/运行一个简单效果\n2. react提供了一个专门用于创建react项目的脚手架库: create-react-app\n3. 项目的整体技术架构为: react + webpack + es6  + babel + eslint\n</code></pre>\n<h2 id=\"_2-创建项目并启动\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-创建项目并启动\"><span>2). 创建项目并启动</span></a></h2>\n<pre><code>npm install -g create-react-app\ncreate-react-app react-app\ncd react-app\nnpm start\n</code></pre>\n<h2 id=\"_3-使用脚手架开发的项目的特点\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-使用脚手架开发的项目的特点\"><span>3). 使用脚手架开发的项目的特点</span></a></h2>\n<pre><code>模块化: js是一个一个模块编写的\n组件化: 界面是由多个组件组合编写实现的\n工程化: 实现了自动构建/运行/打包的项目\n</code></pre>\n<h2 id=\"_4-组件化编写项目的流程\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-组件化编写项目的流程\"><span>4). 组件化编写项目的流程</span></a></h2>\n<pre><code>拆分组件\n实现静态组件---&gt;静态页面\n实现动态组件\n\t动态显示初始化数据\n\t交互\n</code></pre>\n<h1 id=\"_2-app1-实现一个评论管理功能\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-app1-实现一个评论管理功能\"><span>2. app1: 实现一个评论管理功能</span></a></h1>\n<h2 id=\"_1-拆分组件\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-拆分组件\"><span>1). 拆分组件:</span></a></h2>\n<pre><code>应用组件: App\n添加评论组件: CommentAdd\n评论项组件: CommentItem\n评论列表组件: CommentList\n</code></pre>\n<h2 id=\"_2-确定组件的state和props\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-确定组件的state和props\"><span>2). 确定组件的state和props:</span></a></h2>\n<pre><code>App: \n\t* state: comments/array\nCommentAdd\n\t* state: username/string, content/string\n\t* props: add/func\ncommentList\n  \t* props: comments/array, delete/func\nCommentItem\n\t* props: comment/object, delete/func, index/number\n</code></pre>\n<h2 id=\"_3-编写静态组件\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-编写静态组件\"><span>3). 编写静态组件</span></a></h2>\n<pre><code>拆分页面\n拆分css\n</code></pre>\n<h2 id=\"_4-实现动态组件\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-实现动态组件\"><span>4). 实现动态组件</span></a></h2>\n<pre><code>1. 动态展示初始化数据\n  * 初始化状态数据\n  * 传递属性数据\n2. 响应用户操作, 更新组件界面\n  * 绑定事件监听, 并处理\n  * 更新state\n</code></pre>\n<h1 id=\"_3-app2-实现github用户搜索功能\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-app2-实现github用户搜索功能\"><span>3. app2: 实现github用户搜索功能</span></a></h1>\n<h2 id=\"_1-react应用中的ajax请求\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-react应用中的ajax请求\"><span>1). react应用中的ajax请求</span></a></h2>\n<pre><code>axios: 包装XMLHttpRequest对象, promise风格, 支持浏览端/node服务器端\nfetch: 浏览器内置语法, promise风格, 老浏览器不支持, 可以引入fetch.js兼容包\n</code></pre>\n<h2 id=\"_2-拆分组件\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-拆分组件\"><span>2). 拆分组件</span></a></h2>\n<pre><code>App\n\t* state: searchName/string\nSearch\n  \t* props: setSearchName/func\nList\n  \t* props: searchName/string\n  \t* state: firstView/bool, loading/bool, users/array, errMsg/string\n</code></pre>\n<h2 id=\"_3-编写组件\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-编写组件\"><span>3). 编写组件</span></a></h2>\n<pre><code>编写静态组件\n编写动态组件\n\tcomponentWillReceiveProps(nextProps): 监视接收到新的props, 发送ajax\n\t使用axios库发送ajax请求\n</code></pre>\n<h1 id=\"_4-组件间通信总结\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-组件间通信总结\"><span>4. 组件间通信总结</span></a></h1>\n<h2 id=\"_1-方式一-通过props传递\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-方式一-通过props传递\"><span>1). 方式一: 通过props传递</span></a></h2>\n<pre><code>共同的数据放在父组件上, 特有的数据放在自己组件内部(state)\n一般数据--&gt;父组件传递数据给子组件--&gt;子组件读取数据\n函数数据--&gt;子组件传递数据给父组件--&gt;子组件调用函数\n问题: 多层传递属性麻烦, 兄弟组件通信不方便\n</code></pre>\n<h2 id=\"_2-方式二-使用消息订阅-subscribe-发布-publish-机制-自定义事件机制\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-方式二-使用消息订阅-subscribe-发布-publish-机制-自定义事件机制\"><span>2). 方式二: 使用消息订阅(subscribe)-发布(publish)机制: 自定义事件机制</span></a></h2>\n<pre><code>工具库: PubSubJS\n下载: npm install pubsub-js --save\n使用: \n  import PubSub from 'pubsub-js' //引入\n  PubSub.subscribe('delete', function(msg, data){ }); //订阅\n  PubSub.publish('delete', data) //发布消息\n优点: 可以支持任意关系组件之间的通信\n</code></pre>\n<h2 id=\"_3-事件监听理解\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-事件监听理解\"><span>3). 事件监听理解</span></a></h2>\n<pre><code>1. DOM事件\n\t* 绑定事件监听\n\t\t* 事件名(类型): 只有有限的几个, 不能随便写\n\t\t* 回调函数\n\t* 用户操作触发事件(event)\n\t\t* 事件名(类型)\n\t\t* 数据\n2. 自定义事件\n\t* 绑定事件监听\n\t\t* 事件名(类型): 任意\n\t\t* 回调函数: 通过形参接收数据, 在函数体处理事件\n\t* 触发事件(编码)\n\t\t* 事件名(类型): 与绑定的事件监听的事件名一致\n\t\t* 数据: 会自动传递给回调函数\n</code></pre>\n<h1 id=\"_5-es6新语法总结\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_5-es6新语法总结\"><span>5. ES6新语法总结</span></a></h1>\n<pre><code>定义变量/常量: const/let\n解构赋值: let {a, b} = this.props   import {aa} from 'xxx'\n对象的简洁表达: {a, b}\n箭头函数: \n\t组件的自定义方法: xxx = () =&gt; {}\n\tmap/filter的回调方法: (item, index) =&gt; {}\n\t优点:\n\t\t* 简洁\n\t\t* 没有自己的this,使用引用this查找的是外部this\n扩展运算符: ...\n\t拆解对象:  const MyProps = {}, &lt;Xxx {...MyProps}&gt;\n类: class/extends/constructor/super\nES6模块化: export default | import\n</code></pre>\n<h1 id=\"_6-项目打包运行\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_6-项目打包运行\"><span>6. 项目打包运行</span></a></h1>\n<pre><code>npm run build  //生成打包文件\nnpm install -g serve  //全局下载服务器包\nserve build  //通过服务器命令运行打包项目\n访问: http://localhost:5000  //浏览器访问\n</code></pre>\n</template>","contentStripped":"<h1 id=\"_1-使用react脚手架创建一个react应用\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-使用react脚手架创建一个react应用\"><span>1. 使用React脚手架创建一个React应用</span></a></h1>\n<h2 id=\"_1-react脚手架\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-react脚手架\"><span>1). react脚手架</span></a></h2>\n<pre><code>1. xxx脚手架: 用来帮助程序员快速创建一个基于xxx库的模板项目\n\t* 包含了所有需要的配置\n\t* 指定好了所有的依赖\n\t* 可以直接安装/编译/运行一个简单效果\n2. react提供了一个专门用于创建react项目的脚手架库: create-react-app\n3. 项目的整体技术架构为: react + webpack + es6  + babel + eslint\n</code></pre>\n<h2 id=\"_2-创建项目并启动\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-创建项目并启动\"><span>2). 创建项目并启动</span></a></h2>\n<pre><code>npm install -g create-react-app\ncreate-react-app react-app\ncd react-app\nnpm start\n</code></pre>\n<h2 id=\"_3-使用脚手架开发的项目的特点\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-使用脚手架开发的项目的特点\"><span>3). 使用脚手架开发的项目的特点</span></a></h2>\n<pre><code>模块化: js是一个一个模块编写的\n组件化: 界面是由多个组件组合编写实现的\n工程化: 实现了自动构建/运行/打包的项目\n</code></pre>\n<h2 id=\"_4-组件化编写项目的流程\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-组件化编写项目的流程\"><span>4). 组件化编写项目的流程</span></a></h2>\n<pre><code>拆分组件\n实现静态组件---&gt;静态页面\n实现动态组件\n\t动态显示初始化数据\n\t交互\n</code></pre>\n<h1 id=\"_2-app1-实现一个评论管理功能\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-app1-实现一个评论管理功能\"><span>2. app1: 实现一个评论管理功能</span></a></h1>\n<h2 id=\"_1-拆分组件\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-拆分组件\"><span>1). 拆分组件:</span></a></h2>\n<pre><code>应用组件: App\n添加评论组件: CommentAdd\n评论项组件: CommentItem\n评论列表组件: CommentList\n</code></pre>\n<h2 id=\"_2-确定组件的state和props\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-确定组件的state和props\"><span>2). 确定组件的state和props:</span></a></h2>\n<pre><code>App: \n\t* state: comments/array\nCommentAdd\n\t* state: username/string, content/string\n\t* props: add/func\ncommentList\n  \t* props: comments/array, delete/func\nCommentItem\n\t* props: comment/object, delete/func, index/number\n</code></pre>\n<h2 id=\"_3-编写静态组件\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-编写静态组件\"><span>3). 编写静态组件</span></a></h2>\n<pre><code>拆分页面\n拆分css\n</code></pre>\n<h2 id=\"_4-实现动态组件\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-实现动态组件\"><span>4). 实现动态组件</span></a></h2>\n<pre><code>1. 动态展示初始化数据\n  * 初始化状态数据\n  * 传递属性数据\n2. 响应用户操作, 更新组件界面\n  * 绑定事件监听, 并处理\n  * 更新state\n</code></pre>\n<h1 id=\"_3-app2-实现github用户搜索功能\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-app2-实现github用户搜索功能\"><span>3. app2: 实现github用户搜索功能</span></a></h1>\n<h2 id=\"_1-react应用中的ajax请求\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-react应用中的ajax请求\"><span>1). react应用中的ajax请求</span></a></h2>\n<pre><code>axios: 包装XMLHttpRequest对象, promise风格, 支持浏览端/node服务器端\nfetch: 浏览器内置语法, promise风格, 老浏览器不支持, 可以引入fetch.js兼容包\n</code></pre>\n<h2 id=\"_2-拆分组件\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-拆分组件\"><span>2). 拆分组件</span></a></h2>\n<pre><code>App\n\t* state: searchName/string\nSearch\n  \t* props: setSearchName/func\nList\n  \t* props: searchName/string\n  \t* state: firstView/bool, loading/bool, users/array, errMsg/string\n</code></pre>\n<h2 id=\"_3-编写组件\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-编写组件\"><span>3). 编写组件</span></a></h2>\n<pre><code>编写静态组件\n编写动态组件\n\tcomponentWillReceiveProps(nextProps): 监视接收到新的props, 发送ajax\n\t使用axios库发送ajax请求\n</code></pre>\n<h1 id=\"_4-组件间通信总结\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-组件间通信总结\"><span>4. 组件间通信总结</span></a></h1>\n<h2 id=\"_1-方式一-通过props传递\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-方式一-通过props传递\"><span>1). 方式一: 通过props传递</span></a></h2>\n<pre><code>共同的数据放在父组件上, 特有的数据放在自己组件内部(state)\n一般数据--&gt;父组件传递数据给子组件--&gt;子组件读取数据\n函数数据--&gt;子组件传递数据给父组件--&gt;子组件调用函数\n问题: 多层传递属性麻烦, 兄弟组件通信不方便\n</code></pre>\n<h2 id=\"_2-方式二-使用消息订阅-subscribe-发布-publish-机制-自定义事件机制\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-方式二-使用消息订阅-subscribe-发布-publish-机制-自定义事件机制\"><span>2). 方式二: 使用消息订阅(subscribe)-发布(publish)机制: 自定义事件机制</span></a></h2>\n<pre><code>工具库: PubSubJS\n下载: npm install pubsub-js --save\n使用: \n  import PubSub from 'pubsub-js' //引入\n  PubSub.subscribe('delete', function(msg, data){ }); //订阅\n  PubSub.publish('delete', data) //发布消息\n优点: 可以支持任意关系组件之间的通信\n</code></pre>\n<h2 id=\"_3-事件监听理解\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-事件监听理解\"><span>3). 事件监听理解</span></a></h2>\n<pre><code>1. DOM事件\n\t* 绑定事件监听\n\t\t* 事件名(类型): 只有有限的几个, 不能随便写\n\t\t* 回调函数\n\t* 用户操作触发事件(event)\n\t\t* 事件名(类型)\n\t\t* 数据\n2. 自定义事件\n\t* 绑定事件监听\n\t\t* 事件名(类型): 任意\n\t\t* 回调函数: 通过形参接收数据, 在函数体处理事件\n\t* 触发事件(编码)\n\t\t* 事件名(类型): 与绑定的事件监听的事件名一致\n\t\t* 数据: 会自动传递给回调函数\n</code></pre>\n<h1 id=\"_5-es6新语法总结\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_5-es6新语法总结\"><span>5. ES6新语法总结</span></a></h1>\n<pre><code>定义变量/常量: const/let\n解构赋值: let {a, b} = this.props   import {aa} from 'xxx'\n对象的简洁表达: {a, b}\n箭头函数: \n\t组件的自定义方法: xxx = () =&gt; {}\n\tmap/filter的回调方法: (item, index) =&gt; {}\n\t优点:\n\t\t* 简洁\n\t\t* 没有自己的this,使用引用this查找的是外部this\n扩展运算符: ...\n\t拆解对象:  const MyProps = {}, &lt;Xxx {...MyProps}&gt;\n类: class/extends/constructor/super\nES6模块化: export default | import\n</code></pre>\n<h1 id=\"_6-项目打包运行\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_6-项目打包运行\"><span>6. 项目打包运行</span></a></h1>\n<pre><code>npm run build  //生成打包文件\nnpm install -g serve  //全局下载服务器包\nserve build  //通过服务器命令运行打包项目\n访问: http://localhost:5000  //浏览器访问\n</code></pre>\n","tagOpen":"<template>","tagClose":"</template>"},"script":null,"scriptSetup":null,"scripts":[],"styles":[],"customBlocks":[]},"content":"# 1. 使用React脚手架创建一个React应用\r\n## 1). react脚手架\r\n\t1. xxx脚手架: 用来帮助程序员快速创建一个基于xxx库的模板项目\r\n\t\t* 包含了所有需要的配置\r\n\t\t* 指定好了所有的依赖\r\n\t\t* 可以直接安装/编译/运行一个简单效果\r\n\t2. react提供了一个专门用于创建react项目的脚手架库: create-react-app\r\n\t3. 项目的整体技术架构为: react + webpack + es6  + babel + eslint\r\n## 2). 创建项目并启动\r\n\tnpm install -g create-react-app\r\n\tcreate-react-app react-app\r\n\tcd react-app\r\n\tnpm start\r\n## 3). 使用脚手架开发的项目的特点\r\n\t模块化: js是一个一个模块编写的\r\n\t组件化: 界面是由多个组件组合编写实现的\r\n\t工程化: 实现了自动构建/运行/打包的项目\r\n## 4). 组件化编写项目的流程\r\n\t拆分组件\r\n\t实现静态组件--->静态页面\r\n\t实现动态组件\r\n\t\t动态显示初始化数据\r\n\t\t交互\r\n\r\n# 2. app1: 实现一个评论管理功能\r\n## 1). 拆分组件:\r\n\t应用组件: App\r\n\t添加评论组件: CommentAdd\r\n\t评论项组件: CommentItem\r\n\t评论列表组件: CommentList\r\n## 2). 确定组件的state和props:\r\n\tApp: \r\n\t\t* state: comments/array\r\n\tCommentAdd\r\n\t\t* state: username/string, content/string\r\n\t\t* props: add/func\r\n\tcommentList\r\n\t  \t* props: comments/array, delete/func\r\n\tCommentItem\r\n\t\t* props: comment/object, delete/func, index/number\r\n## 3). 编写静态组件\r\n\t拆分页面\r\n\t拆分css\r\n## 4). 实现动态组件\r\n\t1. 动态展示初始化数据\r\n\t  * 初始化状态数据\r\n\t  * 传递属性数据\r\n\t2. 响应用户操作, 更新组件界面\r\n\t  * 绑定事件监听, 并处理\r\n\t  * 更新state\r\n\r\n# 3. app2: 实现github用户搜索功能\r\n## 1). react应用中的ajax请求\r\n\taxios: 包装XMLHttpRequest对象, promise风格, 支持浏览端/node服务器端\r\n\tfetch: 浏览器内置语法, promise风格, 老浏览器不支持, 可以引入fetch.js兼容包\r\n## 2). 拆分组件\r\n    App\r\n\t\t* state: searchName/string\r\n    Search\r\n      \t* props: setSearchName/func\r\n    List\r\n      \t* props: searchName/string\r\n      \t* state: firstView/bool, loading/bool, users/array, errMsg/string\r\n## 3). 编写组件\r\n\t编写静态组件\r\n\t编写动态组件\r\n\t\tcomponentWillReceiveProps(nextProps): 监视接收到新的props, 发送ajax\r\n\t\t使用axios库发送ajax请求\r\n\r\n# 4. 组件间通信总结\r\n## 1). 方式一: 通过props传递\r\n\t共同的数据放在父组件上, 特有的数据放在自己组件内部(state)\r\n\t一般数据-->父组件传递数据给子组件-->子组件读取数据\r\n\t函数数据-->子组件传递数据给父组件-->子组件调用函数\r\n\t问题: 多层传递属性麻烦, 兄弟组件通信不方便\r\n\t\r\n## 2). 方式二: 使用消息订阅(subscribe)-发布(publish)机制: 自定义事件机制\r\n\t工具库: PubSubJS\r\n\t下载: npm install pubsub-js --save\r\n\t使用: \r\n\t  import PubSub from 'pubsub-js' //引入\r\n\t  PubSub.subscribe('delete', function(msg, data){ }); //订阅\r\n\t  PubSub.publish('delete', data) //发布消息\r\n\t优点: 可以支持任意关系组件之间的通信\r\n\r\n## 3). 事件监听理解\r\n\t1. DOM事件\r\n\t\t* 绑定事件监听\r\n\t\t\t* 事件名(类型): 只有有限的几个, 不能随便写\r\n\t\t\t* 回调函数\r\n\t\t* 用户操作触发事件(event)\r\n\t\t\t* 事件名(类型)\r\n\t\t\t* 数据\r\n\t2. 自定义事件\r\n\t\t* 绑定事件监听\r\n\t\t\t* 事件名(类型): 任意\r\n\t\t\t* 回调函数: 通过形参接收数据, 在函数体处理事件\r\n\t\t* 触发事件(编码)\r\n\t\t\t* 事件名(类型): 与绑定的事件监听的事件名一致\r\n\t\t\t* 数据: 会自动传递给回调函数\r\n      \r\n# 5. ES6新语法总结\r\n\t定义变量/常量: const/let\r\n\t解构赋值: let {a, b} = this.props   import {aa} from 'xxx'\r\n\t对象的简洁表达: {a, b}\r\n\t箭头函数: \r\n\t\t组件的自定义方法: xxx = () => {}\r\n\t\tmap/filter的回调方法: (item, index) => {}\r\n\t\t优点:\r\n\t\t\t* 简洁\r\n\t\t\t* 没有自己的this,使用引用this查找的是外部this\r\n\t扩展运算符: ...\r\n\t\t拆解对象:  const MyProps = {}, <Xxx {...MyProps}>\r\n\t类: class/extends/constructor/super\r\n\tES6模块化: export default | import\r\n\r\n# 6. 项目打包运行\r\n\tnpm run build  //生成打包文件\r\n\tnpm install -g serve  //全局下载服务器包\r\n\tserve build  //通过服务器命令运行打包项目\r\n\t访问: http://localhost:5000  //浏览器访问","excerpt":"","includedFiles":[],"tasklistId":0,"title":"1. 使用React脚手架创建一个React应用","headers":[{"level":2,"title":"1). react脚手架","slug":"_1-react脚手架","link":"#_1-react脚手架","children":[]},{"level":2,"title":"2). 创建项目并启动","slug":"_2-创建项目并启动","link":"#_2-创建项目并启动","children":[]},{"level":2,"title":"3). 使用脚手架开发的项目的特点","slug":"_3-使用脚手架开发的项目的特点","link":"#_3-使用脚手架开发的项目的特点","children":[]},{"level":2,"title":"4). 组件化编写项目的流程","slug":"_4-组件化编写项目的流程","link":"#_4-组件化编写项目的流程","children":[]},{"level":2,"title":"1). 拆分组件:","slug":"_1-拆分组件","link":"#_1-拆分组件","children":[]},{"level":2,"title":"2). 确定组件的state和props:","slug":"_2-确定组件的state和props","link":"#_2-确定组件的state和props","children":[]},{"level":2,"title":"3). 编写静态组件","slug":"_3-编写静态组件","link":"#_3-编写静态组件","children":[]},{"level":2,"title":"4). 实现动态组件","slug":"_4-实现动态组件","link":"#_4-实现动态组件","children":[]},{"level":2,"title":"1). react应用中的ajax请求","slug":"_1-react应用中的ajax请求","link":"#_1-react应用中的ajax请求","children":[]},{"level":2,"title":"2). 拆分组件","slug":"_2-拆分组件","link":"#_2-拆分组件","children":[]},{"level":2,"title":"3). 编写组件","slug":"_3-编写组件","link":"#_3-编写组件","children":[]},{"level":2,"title":"1). 方式一: 通过props传递","slug":"_1-方式一-通过props传递","link":"#_1-方式一-通过props传递","children":[]},{"level":2,"title":"2). 方式二: 使用消息订阅(subscribe)-发布(publish)机制: 自定义事件机制","slug":"_2-方式二-使用消息订阅-subscribe-发布-publish-机制-自定义事件机制","link":"#_2-方式二-使用消息订阅-subscribe-发布-publish-机制-自定义事件机制","children":[]},{"level":2,"title":"3). 事件监听理解","slug":"_3-事件监听理解","link":"#_3-事件监听理解","children":[]}]}}
