import{_ as i,c as a,a as n,o as e}from"./app-xRlI9cPS.js";const l={};function t(p,s){return e(),a("div",null,[...s[0]||(s[0]=[n(`<h2 id="_1-setstate" tabindex="-1"><a class="header-anchor" href="#_1-setstate"><span>1. setState</span></a></h2><h3 id="setstate更新状态的2种写法" tabindex="-1"><a class="header-anchor" href="#setstate更新状态的2种写法"><span>setState更新状态的2种写法</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>	(1). setState(stateChange, [callback])------对象式的setState</span></span>
<span class="line"><span>            1.stateChange为状态改变对象(该对象可以体现出状态的更改)</span></span>
<span class="line"><span>            2.callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用</span></span>
<span class="line"><span>					</span></span>
<span class="line"><span>	(2). setState(updater, [callback])------函数式的setState</span></span>
<span class="line"><span>            1.updater为返回stateChange对象的函数。</span></span>
<span class="line"><span>            2.updater可以接收到state和props。</span></span>
<span class="line"><span>            4.callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。</span></span>
<span class="line"><span>总结:</span></span>
<span class="line"><span>		1.对象式的setState是函数式的setState的简写方式(语法糖)</span></span>
<span class="line"><span>		2.使用原则：</span></span>
<span class="line"><span>				(1).如果新状态不依赖于原状态 ===&gt; 使用对象方式</span></span>
<span class="line"><span>				(2).如果新状态依赖于原状态 ===&gt; 使用函数方式</span></span>
<span class="line"><span>				(3).如果需要在setState()执行后获取最新的状态数据, </span></span>
<span class="line"><span>					要在第二个callback函数中读取</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_2-lazyload" tabindex="-1"><a class="header-anchor" href="#_2-lazyload"><span>2. lazyLoad</span></a></h2><h3 id="路由组件的lazyload" tabindex="-1"><a class="header-anchor" href="#路由组件的lazyload"><span>路由组件的lazyLoad</span></a></h3><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">	//1.通过React的lazy函数配合import()函数动态加载路由组件 ===&gt; 路由组件代码会被分开打包</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">	const</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> Login</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> lazy</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(()=&gt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">import</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">@/pages/Login</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">	</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">	//2.通过&lt;Suspense&gt;指定在加载得到路由打包文件前显示一个自定义loading界面</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">	&lt;</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">Suspense</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> fallback</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">={&lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">h1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">loading.....</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;/</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">h1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;}&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        &lt;</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">Switch</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">            &lt;</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">Route</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> path</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">/xxx</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> component</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">={</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Xxxx</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">}/&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">            &lt;</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">Redirect</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> to</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">/login</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">/&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        &lt;/</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">Switch</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    &lt;/</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">Suspense</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_3-hooks" tabindex="-1"><a class="header-anchor" href="#_3-hooks"><span>3. Hooks</span></a></h2><h4 id="_1-react-hook-hooks是什么" tabindex="-1"><a class="header-anchor" href="#_1-react-hook-hooks是什么"><span>1. React Hook/Hooks是什么?</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>(1). Hook是React 16.8.0版本增加的新特性/新语法</span></span>
<span class="line"><span>(2). 可以让你在函数组件中使用 state 以及其他的 React 特性</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-三个常用的hook" tabindex="-1"><a class="header-anchor" href="#_2-三个常用的hook"><span>2. 三个常用的Hook</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>(1). State Hook: React.useState()</span></span>
<span class="line"><span>(2). Effect Hook: React.useEffect()</span></span>
<span class="line"><span>(3). Ref Hook: React.useRef()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-state-hook" tabindex="-1"><a class="header-anchor" href="#_3-state-hook"><span>3. State Hook</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>(1). State Hook让函数组件也可以有state状态, 并进行状态数据的读写操作</span></span>
<span class="line"><span>(2). 语法: const [xxx, setXxx] = React.useState(initValue)  </span></span>
<span class="line"><span>(3). useState()说明:</span></span>
<span class="line"><span>        参数: 第一次初始化指定的值在内部作缓存</span></span>
<span class="line"><span>        返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数</span></span>
<span class="line"><span>(4). setXxx()2种写法:</span></span>
<span class="line"><span>        setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值</span></span>
<span class="line"><span>        setXxx(value =&gt; newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4-effect-hook" tabindex="-1"><a class="header-anchor" href="#_4-effect-hook"><span>4. Effect Hook</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>(1). Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)</span></span>
<span class="line"><span>(2). React中的副作用操作:</span></span>
<span class="line"><span>        发ajax请求数据获取</span></span>
<span class="line"><span>        设置订阅 / 启动定时器</span></span>
<span class="line"><span>        手动更改真实DOM</span></span>
<span class="line"><span>(3). 语法和说明: </span></span>
<span class="line"><span>        useEffect(() =&gt; { </span></span>
<span class="line"><span>          // 在此可以执行任何带副作用操作</span></span>
<span class="line"><span>          return () =&gt; { // 在组件卸载前执行</span></span>
<span class="line"><span>            // 在此做一些收尾工作, 比如清除定时器/取消订阅等</span></span>
<span class="line"><span>          }</span></span>
<span class="line"><span>        }, [stateValue]) // 如果指定的是[], 回调函数只会在第一次render()后执行</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>(4). 可以把 useEffect Hook 看做如下三个函数的组合</span></span>
<span class="line"><span>        componentDidMount()</span></span>
<span class="line"><span>        componentDidUpdate()</span></span>
<span class="line"><span>    	componentWillUnmount()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_5-ref-hook" tabindex="-1"><a class="header-anchor" href="#_5-ref-hook"><span>5. Ref Hook</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>(1). Ref Hook可以在函数组件中存储/查找组件内的标签或任意其它数据</span></span>
<span class="line"><span>(2). 语法: const refContainer = useRef()</span></span>
<span class="line"><span>(3). 作用:保存标签对象,功能与React.createRef()一样</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_4-fragment" tabindex="-1"><a class="header-anchor" href="#_4-fragment"><span>4. Fragment</span></a></h2><h3 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h3><pre><code>&lt;Fragment&gt;&lt;Fragment&gt;
&lt;&gt;&lt;/&gt;
</code></pre><h3 id="作用" tabindex="-1"><a class="header-anchor" href="#作用"><span>作用</span></a></h3><blockquote><p>可以不用必须有一个真实的DOM根标签了</p></blockquote><hr> ## 5. Context <h3 id="理解" tabindex="-1"><a class="header-anchor" href="#理解"><span>理解</span></a></h3><blockquote><p>一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信</p></blockquote><h3 id="使用-1" tabindex="-1"><a class="header-anchor" href="#使用-1"><span>使用</span></a></h3><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">) </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">创建Context容器对象</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">：</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">	const</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> XxxContext</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> React</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">createContext</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">  </span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">	</span></span>
<span class="line"><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">2</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">) </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">渲染子组时</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">，</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">外面包裹xxxContext</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Provider</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> 通过value属性给后代组件传递数据</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">：</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">	&lt;</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">xxxContext.Provider</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> value</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">={</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">数据</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">}&gt;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">		子组件</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    &lt;/</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">xxxContext.Provider</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    </span></span>
<span class="line"><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">3</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">) </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">后代组件读取数据</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">	//第一种方式:仅适用于类组件 </span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">	  static</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> contextType</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> xxxContext</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 声明接收context</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">	  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">context</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 读取context中的value数据</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">	  </span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">	//第二种方式: 函数组件与类组件都可以</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">	  &lt;</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">xxxContext.Consumer</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">	    {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">	      value</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =&gt;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // value就是context中的value数据</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">	        要显示的内容</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">	      )</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">	    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">	  &lt;/</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">xxxContext.Consumer</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="注意" tabindex="-1"><a class="header-anchor" href="#注意"><span>注意</span></a></h3><pre><code>在应用开发中一般不用context, 一般都它的封装react插件
</code></pre><hr> ## 6. 组件优化 <h3 id="component的2个问题" tabindex="-1"><a class="header-anchor" href="#component的2个问题"><span>Component的2个问题</span></a></h3><blockquote><ol><li><p>只要执行setState(),即使不改变状态数据, 组件也会重新render()</p></li><li><p>只当前组件重新render(), 就会自动重新render子组件 ==&gt; 效率低</p></li></ol></blockquote><h3 id="效率高的做法" tabindex="-1"><a class="header-anchor" href="#效率高的做法"><span>效率高的做法</span></a></h3><blockquote><p>只有当组件的state或props数据发生改变时才重新render()</p></blockquote><h3 id="原因" tabindex="-1"><a class="header-anchor" href="#原因"><span>原因</span></a></h3><blockquote><p>Component中的shouldComponentUpdate()总是返回true</p></blockquote><h3 id="解决" tabindex="-1"><a class="header-anchor" href="#解决"><span>解决</span></a></h3><pre><code>办法1: 
	重写shouldComponentUpdate()方法
	比较新旧state或props数据, 如果有变化才返回true, 如果没有返回false
办法2:  
	使用PureComponent
	PureComponent重写了shouldComponentUpdate(), 只有state或props数据有变化才返回true
	注意: 
		只是进行state和props数据的浅比较, 如果只是数据对象内部数据变了, 返回false  
		不要直接修改state数据, 而是要产生新数据
项目中一般使用PureComponent来优化
</code></pre><hr> ## 7. render props <h3 id="如何向组件内部动态传入带内容的结构-标签" tabindex="-1"><a class="header-anchor" href="#如何向组件内部动态传入带内容的结构-标签"><span>如何向组件内部动态传入带内容的结构(标签)?</span></a></h3><pre><code>Vue中: 
	使用slot技术, 也就是通过组件标签体传入结构  &lt;AA&gt;&lt;BB/&gt;&lt;/AA&gt;
React中:
	使用children props: 通过组件标签体传入结构
	使用render props: 通过组件标签属性传入结构, 一般用render函数属性
</code></pre><h3 id="children-props" tabindex="-1"><a class="header-anchor" href="#children-props"><span>children props</span></a></h3><pre><code>&lt;A&gt;
  &lt;B&gt;xxxx&lt;/B&gt;
&lt;/A&gt;
{this.props.children}
问题: 如果B组件需要A组件内的数据, ==&gt; 做不到 
</code></pre><h3 id="render-props" tabindex="-1"><a class="header-anchor" href="#render-props"><span>render props</span></a></h3><pre><code>&lt;A render={(data) =&gt; &lt;C data={data}&gt;&lt;/C&gt;}&gt;&lt;/A&gt;
A组件: {this.props.render(内部state数据)}
C组件: 读取A组件传入的数据显示 {this.props.data} 
</code></pre><hr> ## 8. 错误边界 <h4 id="理解-1" tabindex="-1"><a class="header-anchor" href="#理解-1"><span>理解：</span></a></h4><p>错误边界：用来捕获后代组件错误，渲染出备用页面</p><h4 id="特点" tabindex="-1"><a class="header-anchor" href="#特点"><span>特点：</span></a></h4><p>只能捕获后代组件生命周期产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误</p><h5 id="使用方式" tabindex="-1"><a class="header-anchor" href="#使用方式"><span>使用方式：</span></a></h5><p>getDerivedStateFromError配合componentDidCatch</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 生命周期函数，一旦后台组件报错，就会触发</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">static</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> getDerivedStateFromError</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">error</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">    console</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">log</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">error</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 在render之前触发</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 返回新的state</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">        hasError</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> true</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    };</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">componentDidCatch</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">error</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> info</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 统计页面的错误。发送请求发送到后台去</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">    console</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">log</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">error</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> info</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_9-组件通信方式总结" tabindex="-1"><a class="header-anchor" href="#_9-组件通信方式总结"><span>9. 组件通信方式总结</span></a></h2><h4 id="方式" tabindex="-1"><a class="header-anchor" href="#方式"><span>方式：</span></a></h4><pre><code>	props：
		(1).children props
		(2).render props
	消息订阅-发布：
		pubs-sub、event等等
	集中式管理：
		redux、dva等等
	conText:
		生产者-消费者模式
</code></pre><h4 id="组件间的关系" tabindex="-1"><a class="header-anchor" href="#组件间的关系"><span>组件间的关系</span></a></h4><pre><code>	父子组件：props
	兄弟组件(非嵌套组件)：消息订阅-发布、集中式管理
	祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(用的少)
</code></pre>`,65)])])}const d=i(l,[["render",t]]),r=JSON.parse('{"path":"/article/pd67uli2/","title":"React扩展","lang":"zh-CN","frontmatter":{"title":"React扩展","date":"2022-08-04T00:00:00.000Z","tags":["React"],"categories":["自学篇"],"createTime":"2025/08/24 00:25:17","permalink":"/article/pd67uli2/"},"readingTime":{"minutes":5.44,"words":1633},"git":{"createdTime":1762223206000,"updatedTime":1762223792000,"contributors":[{"name":"袁果锅","username":"","email":"2914310412@qq.com","commits":2,"avatar":"https://gravatar.com/avatar/ebb36e92893d0bad96657e83c4e1e8be47c5ebe9e1f87275acd48573e4759004?d=retro"}]},"filePathRelative":"React笔记/尚硅谷React扩展笔记.md","headers":[],"categoryList":[{"id":"5782db","sort":10010,"name":"React笔记"}]}');export{d as comp,r as data};
